package rtda

/*
    在运行Java程序时,Java虚拟机需要使用内存来存放各式各样的数据.Java虚拟机规范把这些内存区域叫作运行时数据区.
运行时数据区可以分为两类:1.多线程共享的;2.线程私有的.
多线程共享的运行时数据区需要在Java虚拟机启动时创建好,在Java虚拟机退出时销毁.线程私有的运行时数据区则在创建线程时才创建,线程退出时销毁.
    多线程共享的内存区域主要存放两类数据:类数据和类实例.对象数据存放在堆(Heap)中,类数据存放在方法区(Method Area)中.
堆由垃圾回收器定期清理,所以程序员不需要关心对象空间的释放.类数据包括字段和方法信息,方法的字节码,运行时常量池,etc.
从逻辑上来讲,方法区其实也是堆的一部分.
    线程私有的运行时数据区用于辅助执行Java字节码.每个线程都有自己的pc寄存器和Java虚拟机栈.Java虚拟机栈又由栈帧(Stack Frame)构成.
栈帧中保存方法执行的状态,包括局部变量表和操作数栈,etc.在任一时刻,某一线程肯定是在执行某个方法.
这个方法叫作该线程的当前方法;执行该方法的栈帧叫作线程的当前栈帧;申明该方法的类叫作当前类.
如果当前方法是Java方法,则pc寄存器中存放当前正在执行的Java虚拟机指令的地址,否则,当前方法是本地方法,pc寄存器中的值没有明确定义.

|-----------------------------------------------------------------------------|
|                            Run-Time Data Area                               |
| |---------------------------------|     |---------------------------------| |
| |             Thread              |     |              Heap               | |
| | |-----------------------------| |     | |-----------------------------| | |
| | |             pc              | |     | |         Method Area         | | |
| | |-----------------------------| |     | | |-------------------------| | | |
| |                                 |     | | |          Class          | | | |
| | |-----------------------------| |     | | | |---------------------| | | | |
| | |          JVM Stack          | |     | | | |       Run-Time      | | | | |
| | | |-------------------------| | |     | | | |     Constant Pool   | | | | |
| | | |          Frame          | | |     | | | |_____________________| | | | |
| | | | |---------------------| | | |     | | |_________________________| | | |
| | | | |   Local Variable    | | | |     | |_____________________________| | |
| | | | |_____________________| | | |     |                                 | |
| | | |                         | | |     | |-----------------------------| | |
| | | | |---------------------| | | |     | |                             | | |
| | | | |    Operand Stack    | | | |     | |           Object            | | |
| | | | |_____________________| | | |     | |                             | | |
| | | |_________________________| | |     | |_____________________________| | |
| | |_____________________________| |     |                                 | |
| |_________________________________|     |_________________________________| |
|_____________________________________________________________________________|

    Java虚拟机规范对于运行时数据区的规定是相当宽松的.以堆为例:堆可以是连续空间,也可以不连续.堆的大小可以固定,也可以在运行时按需扩展.
虚拟机实现者可以使用任何垃圾回收算法管理堆,甚至完全不进行垃圾回收也是可以的.由于Go本身也有垃圾回收功能,所以可以直接使用Go的堆和垃圾回收器.
    Java命令提供了-Xms和-Xmx两个非标准选项,用来调整堆的初始大小和最大大小.
    Java虚拟机可以操作两类数据:基本类型(primitive type)和引用类型(reference type).
基本类型的变量存放的就是数据本身,引用类型的变量存放的是对象引用,真正的对象数据是在堆里分配的.
变量包括类变量(静态字段),实例变量(非静态字段),数组元素,方法的参数和局部变量,etc.
    基本类型可以进一步分为布尔类型和数字类型,数字类型又可以分为整数类型和浮点型类型.引用类型可以进一步分为3种:类类型,接口类型和数组类型.
类类型引用指向类实例,数组类型指向数组实例,接口类型引用指向实现了该接口的类或数组实例.引用类型有一个特殊的值--null,表示该引用不指向任何对象.
    Go语言提供了非常丰富的数据类型,包括各种整数和两种精度的浮点数.Java和Go的浮点数都采用IEEE 754规范.
对于基本类型,可以直接在Go和Java之间建立映射关系.对于引用类型,自然的选择是使用指针.Go的nil,表示空指针,可以表示null.
 */

type Object struct {

}
